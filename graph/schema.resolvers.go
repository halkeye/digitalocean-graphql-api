package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45-dev

import (
	"context"
	"encoding/base64"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/digitalocean/godo"
	"github.com/sirupsen/logrus"

	"github.com/halkeye/digitalocean-graphql-api/graph/digitalocean"
	"github.com/halkeye/digitalocean-graphql-api/graph/loaders"
	"github.com/halkeye/digitalocean-graphql-api/graph/logger"
	"github.com/halkeye/digitalocean-graphql-api/graph/model"
	"github.com/halkeye/digitalocean-graphql-api/graph/model_helpers"
)

// Project is the resolver for the project field.
func (r *activityHistoryResolver) Project(ctx context.Context, obj *model.ActivityHistory) (*model.Project, error) {
	panic(fmt.Errorf("not implemented: Project - project"))
}

// Resource is the resolver for the resource field.
func (r *activityHistoryResolver) Resource(ctx context.Context, obj *model.ActivityHistory) (model.Resource, error) {
	panic(fmt.Errorf("not implemented: Resource - resource"))
}

// User is the resolver for the user field.
func (r *activityHistoryResolver) User(ctx context.Context, obj *model.ActivityHistory) (*model.Account, error) {
	panic(fmt.Errorf("not implemented: User - user"))
}

// Resources is the resolver for the resources field.
func (r *projectResolver) Resources(ctx context.Context, obj *model.Project, first *int, after *string) (*model.ProjectResourcesConnection, error) {
	doClient, err := digitalocean.For(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to get do client: %w", err)
	}

	ll, err := logger.For(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to get logger: %w", err)
	}

	ll = ll.WithField("resolver", "Resources").WithField("parent.id", obj.ID)
	ll.Info("debug")

	opts := &godo.ListOptions{
		Page:    1,
		PerPage: *first,
	}

	if after != nil {
		b, err := base64.StdEncoding.DecodeString(*after)
		if err != nil {
			return nil, err
		}
		opts.Page, err = strconv.Atoi(string(b))
		if err != nil {
			return nil, fmt.Errorf("unable to process cursor: %w", err)
		}
	}

	edges := make([]*model.ProjectResourcesEdge, *first)
	count := 0

	ll.WithField("project.id", strings.Replace(obj.ID, "do:project:", "", 1)).WithField("opts", opts).Info("doClient.Projects.ListResources")

	projectResources, resp, err := doClient.Projects.ListResources(ctx, strings.Replace(obj.ID, "do:project:", "", 1), opts)
	if err != nil {
		return nil, fmt.Errorf("unable to get projects: %w", err)
	}

	for _, pr := range projectResources {
		assignedAt, err := time.Parse(time.RFC3339, pr.AssignedAt)
		if err != nil {
			return nil, fmt.Errorf("unable to parse assignedAt at: %w", err)
		}

		id := fmt.Sprintf("do:projectresource:%s", pr.URN)
		edges[count] = &model.ProjectResourcesEdge{
			Cursor: base64.StdEncoding.EncodeToString([]byte(id)),
			Node: &model.ProjectResource{
				ID:         id,
				AssignedAt: assignedAt,
				Status:     pr.Status,
			},
		}
		count++
	}

	mc := &model.ProjectResourcesConnection{
		Edges: edges[:count],
		PageInfo: &model.PageInfo{
			HasPreviousPage: opts.Page != 1,
			HasNextPage:     !resp.Links.IsLastPage(),
		},
	}
	if mc.PageInfo.HasPreviousPage {
		mc.PageInfo.StartCursor = mustStringPtr(base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%d", opts.Page))))
	}
	if mc.PageInfo.HasNextPage {
		mc.PageInfo.EndCursor = mustStringPtr(base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%d", opts.Page+1))))
	}

	return mc, nil
}

// ActivityHistory is the resolver for the activity_history field.
func (r *projectResolver) ActivityHistory(ctx context.Context, obj *model.Project, first *int, after *string) (*model.ActivityHistoriesConnection, error) {
	/*
		doClient, err := digitalocean.For(ctx)
		if err != nil {
			return nil, fmt.Errorf("unable to get do client: %w", err)
		}

		ll, err := logger.For(ctx)
		if err != nil {
			return nil, fmt.Errorf("unable to get logger: %w", err)
		}

		ll = ll.WithField("resolver", "Resources").WithField("parent.id", obj.ID)
		ll.Info("debug")

		opts := &godo.ListOptions{
			Page:    1,
			PerPage: *first,
		}

		if after != nil {
			b, err := base64.StdEncoding.DecodeString(*after)
			if err != nil {
				return nil, err
			}
			opts.Page, err = strconv.Atoi(string(b))
			if err != nil {
				return nil, fmt.Errorf("unable to process cursor: %w", err)
			}
		}

		edges := make([]*model.ActivityHistoriesEdge, *first)
		count := 0

		ll.WithField("project.id", strings.Replace(obj.ID, "do:project:", "", 1)).WithField("opts", opts).Info("doClient.Projects.ListResources")

		req, err := doClient.NewRequest(ctx, http.MethodGet, path.Join("v1/fleets", strings.Replace(obj.ID, "do:project:", "", 1), "activity_history"), nil)
		if err != nil {
			return nil, fmt.Errorf("unable to get from do: %w", err)
		}

		root := new(projectActivities)
		resp, err := doClient.Do(ctx, req, root)
		if err != nil {
			return nil, fmt.Errorf("unable to fetch activities: %w", err)
		}

		for _, activity := range root.Activities {
			id := fmt.Sprintf("do:activity_history:%d", activity.ID)
			edges[count] = &model.ActivityHistoriesEdge{
				Cursor: base64.StdEncoding.EncodeToString([]byte(id)),
				Node: &model.ActivityHistory{
					ID:      id,
					Action:  activity.Action,
					Project: &model.Project{},
					Resource: model.Domain{
						ID:   fmt.Sprintf("do:%s:%s", activity.ResourceType, activity.ResourceUUID),
						Name: activity.ResourceName,
					},
					IPAddress: activity.IPAddress,
					EventTime: activity.EventTime,
					User:      &model.Account{},
				},
			}
			count++
		}

		mc := &model.ActivityHistoriesConnection{
			Edges: edges[:count],
			PageInfo: &model.PageInfo{
				HasPreviousPage: opts.Page != 1,
				HasNextPage:     !resp.Links.IsLastPage(),
			},
		}
		if mc.PageInfo.HasPreviousPage {
			mc.PageInfo.StartCursor = mustStringPtr(base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%d", opts.Page))))
		}
		if mc.PageInfo.HasNextPage {
			mc.PageInfo.EndCursor = mustStringPtr(base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%d", opts.Page+1))))
		}

		return mc, nil
	*/
	return nil, nil
}

// Resource is the resolver for the resource field.
func (r *projectResourceResolver) Resource(ctx context.Context, obj *model.ProjectResource) (model.Resource, error) {
	ll, err := logger.For(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to get logger: %w", err)
	}
	ll = ll.WithField("resolver", "resolver").WithField("parent.id", obj.ID)
	ll.Info("debug")
	parts := strings.Split(strings.Replace(obj.ID, "do:projectresource:do:", "", 1), ":")
	switch parts[0] {
	case "droplet":
		return loaders.GetDroplet(ctx, parts[1])
	case "app":
		return loaders.GetApp(ctx, parts[1])
	case "volume":
		return nil, fmt.Errorf("projectResourceResolver.Resource - volume not implemented")
	case "domain":
		return loaders.GetDomain(ctx, parts[1])
	case "spaces":
		return nil, fmt.Errorf("projectResourceResolver.Resource - domain not implemented")
	default:
		panic(fmt.Errorf("not implemented: Resource - resource: %s for %s", parts[1], obj.ID))
	}
}

// Node is the resolver for the node field.
func (r *queryResolver) Node(ctx context.Context, id string) (model.Node, error) {
	ll, err := logger.For(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to get do client: %w", err)
	}
	ll = ll.WithField("resolver", "query").WithField("id", id)
	ll.Info("debug")

	parts := strings.Split(id, ":")
	if len(parts) != 3 {
		return nil, fmt.Errorf("not a valid do urn")
	}

	if parts[0] != "do" {
		return nil, fmt.Errorf("not a valid do urn: namespace")
	}

	switch parts[1] {
	case "project":
		return loaders.GetProject(ctx, parts[2])
	case "droplet":
		return loaders.GetDroplet(ctx, parts[2])
	case "app":
		return loaders.GetApp(ctx, parts[2])
	case "volume":
		return nil, fmt.Errorf("projectResourceResolver.Resource - volume not implemented")
	case "domain":
		return loaders.GetDomain(ctx, parts[2])
	case "spaces":
		return nil, fmt.Errorf("projectResourceResolver.Resource - domain not implemented")
	default:
		return nil, fmt.Errorf("not a valid do urn: collection")
	}
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context, first *int, after *string, last *int, before *string) (*model.ProjectsConnection, error) {
	// FIXME - ordering should be consistent -
	// https://relay.dev/graphql/connections.htm#sec-Edge-order
	// You may order the edges however your business logic dictates, and may determine the ordering based upon additional arguments not covered by this specification. But the ordering must be consistent from page to page, and importantly, The ordering of edges should be the same when using first/after as when using last/before, all other arguments being equal. It should not be reversed when using last/before. More formally:
	// When before: cursor is used, the edge closest to cursor must come last in the result edges.
	// When after: cursor is used, the edge closest to cursor must come first in the result edges.

	doClient, err := digitalocean.For(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to get do client: %w", err)
	}

	ll, err := logger.For(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to get logger: %w", err)
	}
	ll = ll.WithField("resolver", "projects")

	if first == nil {
		first = new(int)
		*first = 10
	}

	opts := &godo.ListOptions{
		Page:    1,
		PerPage: *first,
	}

	if after != nil {
		b, err := base64.StdEncoding.DecodeString(*after)
		if err != nil {
			return nil, err
		}
		opts.Page, err = strconv.Atoi(string(b))
		if err != nil {
			return nil, fmt.Errorf("unable to process cursor: %w", err)
		}
	}
	ll = ll.WithFields(logrus.Fields{
		"first":        *first,
		"opts.page":    opts.Page,
		"opts.perpage": opts.PerPage,
	})
	ll.Info("debug")

	edges := make([]*model.ProjectsEdge, *first)
	count := 0

	projects, resp, err := doClient.Projects.List(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("unable to get projects: %w", err)
	}

	for _, p := range projects {
		node := model_helpers.ProjectFromGodo(&p)
		edges[count] = &model.ProjectsEdge{
			Cursor: base64.StdEncoding.EncodeToString([]byte(node.ID)),
			Node:   node,
		}
		count++
	}

	page := 0
	if resp.Links == nil {
		page, err = resp.Links.CurrentPage()
		if err != nil {
			return nil, fmt.Errorf("unable to get current page: %w", err)
		}
	}
	ll.WithField("page", page).Info("next page")

	mc := &model.ProjectsConnection{
		Edges: edges[:count],
		PageInfo: &model.PageInfo{
			HasPreviousPage: opts.Page != 1,
			HasNextPage:     !resp.Links.IsLastPage(),
		},
	}
	if mc.PageInfo.HasPreviousPage {
		mc.PageInfo.StartCursor = mustStringPtr(base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%d", opts.Page-1))))
	}
	if mc.PageInfo.HasNextPage {
		mc.PageInfo.EndCursor = mustStringPtr(base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%d", opts.Page+1))))
	}

	return mc, nil
}

// Account is the resolver for the account field.
func (r *queryResolver) Account(ctx context.Context) (*model.Account, error) {
	doClient, err := digitalocean.For(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to get do client: %w", err)
	}

	ll, err := logger.For(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to get logger: %w", err)
	}
	ll = ll.WithField("resolver", "account")
	ll.Info("get account")

	clientAccount, _, err := doClient.Account.Get(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to get accounts: %w", err)
	}
	return model_helpers.AccountFromGodo(clientAccount), nil
}

type activityHistoryResolver struct{ *Resolver }
type projectResolver struct{ *Resolver }
type projectResourceResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
type projectActivities struct {
	Activities []struct {
		ID           int       `json:"id"`
		Action       string    `json:"action"`
		ResourceUUID string    `json:"resource_uuid"`
		ResourceType string    `json:"resource_type"`
		ResourceName string    `json:"resource_name"`
		FleetUUID    string    `json:"fleet_uuid"`
		IPAddress    string    `json:"ip_address"`
		EventTime    time.Time `json:"event_time"`
		User         struct {
			ID   int    `json:"id"`
			UUID string `json:"uuid"`
			Name string `json:"name"`
		} `json:"user"`
	} `json:"activities"`
	Links *godo.Links `json:"links,omitempty"`
	Meta  *godo.Meta  `json:"meta"`
}
