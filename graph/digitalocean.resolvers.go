package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"encoding/base64"
	"fmt"
	"strconv"
	"time"

	"github.com/digitalocean/godo"
	"github.com/google/uuid"
	"github.com/pkg/errors"

	"github.com/halkeye/digitalocean-graphql-api/graph/model"
)

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context, first *int, after *string) (*model.ProjectsConnection, error) {
	doClient, err := DoClientFromContext(ctx)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get do client")
	}

	opts := &godo.ListOptions{
		Page:    1,
		PerPage: *first,
	}

	if after != nil {
		b, err := base64.StdEncoding.DecodeString(*after)
		if err != nil {
			return nil, err
		}
		opts.Page, err = strconv.Atoi(string(b))
		if err != nil {
			return nil, errors.Wrap(err, "unable to process cursor")
		}
	}

	fmt.Println(opts)

	edges := make([]*model.ProjectsEdge, *first)
	count := 0

	projects, resp, err := doClient.Projects.List(ctx, opts)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get projects")
	}

	for _, p := range projects {
		parsedUUID, err := uuid.Parse(p.OwnerUUID)
		if err != nil {
			return nil, errors.Wrap(err, "unable to parse uuid")
		}

		createdAt, err := time.Parse(time.RFC3339, p.CreatedAt)
		if err != nil {
			return nil, errors.Wrap(err, "unable to parse created at")
		}

		updatedAt, err := time.Parse(time.RFC3339, p.UpdatedAt)
		if err != nil {
			return nil, errors.Wrap(err, "unable to parse updated at")
		}

		id := fmt.Sprintf("do:project:%s", p.ID)
		edges[count] = &model.ProjectsEdge{
			Cursor: base64.StdEncoding.EncodeToString([]byte(id)),
			Node: &model.Project{
				ID:          id,
				Owner:       &model.Team{ID: fmt.Sprintf("do:team:%s", p.OwnerUUID), UUID: parsedUUID},
				Name:        p.Name,
				Description: &p.Description,
				Purpose:     p.Purpose,
				Environment: p.Environment,
				IsDefault:   p.IsDefault,
				CreatedAt:   &createdAt,
				UpdatedAt:   &updatedAt,
			},
		}
		count++
	}

	page := 0
	if resp.Links == nil {
		page, err = resp.Links.CurrentPage()
		if err != nil {
			return nil, errors.Wrap(err, "unable to get current page")
		}
	}
	fmt.Printf("page: %d\n", page)

	mc := &model.ProjectsConnection{
		Edges: edges[:count],
		PageInfo: &model.PageInfo{
			HasPreviousPage: opts.Page != 1,
			HasNextPage:     !resp.Links.IsLastPage(),
		},
	}
	if mc.PageInfo.HasPreviousPage {
		mc.PageInfo.StartCursor = mustStringPtr(base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%d", opts.Page))))
	}
	if mc.PageInfo.HasNextPage {
		mc.PageInfo.EndCursor = mustStringPtr(base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%d", opts.Page+1))))
	}

	return mc, nil
}
