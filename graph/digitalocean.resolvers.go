package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"encoding/base64"
	"fmt"
	"strconv"
	"strings"
	"time"

	"github.com/digitalocean/godo"
	"github.com/google/uuid"

	"github.com/halkeye/digitalocean-graphql-api/graph/digitalocean"
	"github.com/halkeye/digitalocean-graphql-api/graph/loaders"
	"github.com/halkeye/digitalocean-graphql-api/graph/model"
)

// Resources is the resolver for the resources field.
func (r *projectResolver) Resources(ctx context.Context, obj *model.Project, first *int, after *string) (*model.ProjectResourcesConnection, error) {
	doClient, err := digitalocean.For(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to get do client: %w", err)
	}

	opts := &godo.ListOptions{
		Page:    1,
		PerPage: *first,
	}

	if after != nil {
		b, err := base64.StdEncoding.DecodeString(*after)
		if err != nil {
			return nil, err
		}
		opts.Page, err = strconv.Atoi(string(b))
		if err != nil {
			return nil, fmt.Errorf("unable to process cursor: %w", err)
		}
	}

	edges := make([]*model.ProjectResourcesEdge, *first)
	count := 0

	projectResources, resp, err := doClient.Projects.ListResources(ctx, strings.Replace(obj.ID, "do:project:", "", 1), opts)
	if err != nil {
		return nil, fmt.Errorf("unable to get projects: %w", err)
	}

	for _, pr := range projectResources {
		assignedAt, err := time.Parse(time.RFC3339, pr.AssignedAt)
		if err != nil {
			return nil, fmt.Errorf("unable to parse assignedAt at: %w", err)
		}

		id := fmt.Sprintf("do:projectresource:%s", pr.URN)
		edges[count] = &model.ProjectResourcesEdge{
			Cursor: base64.StdEncoding.EncodeToString([]byte(id)),
			Node: &model.ProjectResource{
				ID:         id,
				AssignedAt: assignedAt,
				Status:     pr.Status,
			},
		}
		count++
	}

	mc := &model.ProjectResourcesConnection{
		Edges: edges[:count],
		PageInfo: &model.PageInfo{
			HasPreviousPage: opts.Page != 1,
			HasNextPage:     !resp.Links.IsLastPage(),
		},
	}
	if mc.PageInfo.HasPreviousPage {
		mc.PageInfo.StartCursor = mustStringPtr(base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%d", opts.Page))))
	}
	if mc.PageInfo.HasNextPage {
		mc.PageInfo.EndCursor = mustStringPtr(base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%d", opts.Page+1))))
	}

	return mc, nil
}

// Resource is the resolver for the resource field.
func (r *projectResourceResolver) Resource(ctx context.Context, obj *model.ProjectResource) (model.Resource, error) {
	fmt.Printf("ID: %s\n", obj.ID)
	parts := strings.Split(strings.Replace(obj.ID, "do:projectresource:do:", "", 1), ":")
	fmt.Printf("Parts: %v\n", parts)
	switch parts[0] {
	case "droplet":
		return loaders.GetDroplet(ctx, parts[1])
	case "app":
		return loaders.GetApp(ctx, parts[1])
	case "volume":
		return nil, fmt.Errorf("projectResourceResolver.Resource - volume not implemented")
	case "domain":
		return loaders.GetDomain(ctx, parts[1])
	case "spaces":
		return nil, fmt.Errorf("projectResourceResolver.Resource - domain not implemented")
	default:
		panic(fmt.Errorf("not implemented: Resource - resource: %s for %s", parts[1], obj.ID))
	}
}

// Projects is the resolver for the projects field.
func (r *queryResolver) Projects(ctx context.Context, first *int, after *string) (*model.ProjectsConnection, error) {
	doClient, err := digitalocean.For(ctx)
	if err != nil {
		return nil, fmt.Errorf("unable to get do client: %w", err)
	}

	if first == nil {
		first = new(int)
		*first = 10
	}

	opts := &godo.ListOptions{
		Page:    1,
		PerPage: *first,
	}

	if after != nil {
		b, err := base64.StdEncoding.DecodeString(*after)
		if err != nil {
			return nil, err
		}
		opts.Page, err = strconv.Atoi(string(b))
		if err != nil {
			return nil, fmt.Errorf("unable to process cursor: %w", err)
		}
	}

	fmt.Printf("[Projects] first: %v\n", first)
	fmt.Printf("[Projects] opts.Page: %d\n", opts.Page)
	fmt.Printf("[Projects] opts.PerPage: %d\n", opts.PerPage)

	edges := make([]*model.ProjectsEdge, *first)
	count := 0

	projects, resp, err := doClient.Projects.List(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("unable to get projects: %w", err)
	}

	for _, p := range projects {
		parsedUUID, err := uuid.Parse(p.OwnerUUID)
		if err != nil {
			return nil, fmt.Errorf("unable to parse uuid: %w", err)
		}

		createdAt, err := time.Parse(time.RFC3339, p.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("unable to parse created at: %w", err)
		}

		updatedAt, err := time.Parse(time.RFC3339, p.UpdatedAt)
		if err != nil {
			return nil, fmt.Errorf("unable to parse updated at: %w", err)
		}

		id := fmt.Sprintf("do:project:%s", p.ID)
		edges[count] = &model.ProjectsEdge{
			Cursor: base64.StdEncoding.EncodeToString([]byte(id)),
			Node: &model.Project{
				ID:          id,
				Owner:       &model.Team{ID: fmt.Sprintf("do:team:%s", p.OwnerUUID), UUID: parsedUUID},
				Name:        p.Name,
				Description: &p.Description,
				Purpose:     p.Purpose,
				Environment: p.Environment,
				IsDefault:   p.IsDefault,
				CreatedAt:   &createdAt,
				UpdatedAt:   &updatedAt,
			},
		}
		count++
	}

	page := 0
	if resp.Links == nil {
		page, err = resp.Links.CurrentPage()
		if err != nil {
			return nil, fmt.Errorf("unable to get current page: %w", err)
		}
	}
	fmt.Printf("[Projects] next page: %d\n", page)

	mc := &model.ProjectsConnection{
		Edges: edges[:count],
		PageInfo: &model.PageInfo{
			HasPreviousPage: opts.Page != 1,
			HasNextPage:     !resp.Links.IsLastPage(),
		},
	}
	if mc.PageInfo.HasPreviousPage {
		mc.PageInfo.StartCursor = mustStringPtr(base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%d", opts.Page-1))))
	}
	if mc.PageInfo.HasNextPage {
		mc.PageInfo.EndCursor = mustStringPtr(base64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%d", opts.Page+1))))
	}

	return mc, nil
}

// Project returns ProjectResolver implementation.
func (r *Resolver) Project() ProjectResolver { return &projectResolver{r} }

// ProjectResource returns ProjectResourceResolver implementation.
func (r *Resolver) ProjectResource() ProjectResourceResolver { return &projectResourceResolver{r} }

type projectResolver struct{ *Resolver }
type projectResourceResolver struct{ *Resolver }
